Esri scripts:

// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS
// @output_file_name default.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/main.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/QueryLayer.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/SQLquery.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/SelectionSet.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/advancedTools.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/cluster.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/mapBasemaps.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/mapLayers.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/places.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/print.js
// @code_url http://domorewithmaps.com/mpf/scripts/esri/selectByAttrs.js
// ==/ClosureCompiler==

// ADD YOUR CODE HERE
/*------------------------------------*/
// TOGGLE MAP LAYER ON AND OFF
/*------------------------------------*/  
function toggleMapLayer(layerid){

    var layer = feMap.mapFrame.getLayer(layerid);
	if(layer){
		//if visible hide the layer
		if(layer.visible) {
			switchOff(layerid);
			removeGraphics();
			feMap.mapFrame.infoWindow.hide();
		}
		//otherwise show and add to feMap.activeLayers. Start the spinner - it will stop once the layer has loaded
		else {
			switchOn(layerid);
		}
		
	//If this is not a layer in the map, it may be a clustered layer	
	} else {
		var numClayers = feMap.clusterLayers.length;
		for (var x = 0; x < numClayers; x++) {
			var cLayer = feMap.clusterLayers[x];
			if(layerid == cLayer.id) {
				//Display the spinner, either for this layer individually or for the Layers dropdown
				if(!cLayer.visible) {
					cLayer.visible = true;
					cLayer.setVisibility(true);
				} else {
					cLayer.visible = false;
					//SL. Remove any highlight graphics, close the infoWindow
					removeGraphics();
					feMap.mapFrame.infoWindow.hide();
					cLayer.setVisibility(false);
				}
				//jQuery('#layersButton span').addClass('loading');
			}		
		}	
	}

	
}
/*------------------------------------*/
// Info Window Connect
/*------------------------------------*/
function displayInfoWindowConnect(evt){
	displayInfoWindow(evt, this.layerIndex);
}

/*------------------------------------*/
// HIDE ALL MAP LAYERS
/*------------------------------------*/
function hideAllMapLayers(){

	// EMPTY ACTIVE LAYERS
	feMap.activeLayers = [];
	// REMOVED CHECKED
	jQuery('#layersList .layer').removeClass('checked');
	hideLayerInfo();
	// HIDE ALL LAYERS
	
  var numLayers = feMap.mapLayers.length;
  for(var i=0; i < numLayers; i++){
  	try {
	  	var layer = feMap.mapLayers[i];
  		if(layer.allowIdentify){
	  		removeFromIdentifyLayers(layer);
  		}
  		if(layer.tiles) {
  			updateTiles();
  			removeFromTileLayers(layer.id); 
  		}
  		feMap.mapFrame.removeLayer(layer);
  		
  	}catch(err){
		console.log("problem deleting layers");
  	}
  }
  feMap.mapLayers = [];
  
  //remove all cluster layers
  var numClusterLayers = feMap.clusterLayers.length;
  for(var i=0; i < numClusterLayers; i++){
  	try {
	  	var cLayer = feMap.clusterLayers[i];
  	  	cLayer.clear();
  	  	dojo.disconnect(cLayer.listener);
  	  	feMap.mapFrame.removeLayer(cLayer.graphics);  		
  	}catch(err){
  		console.log("problem deleting cluster layers");
  	}
  }
  feMap.clusterLayers = [];
  
	//Remove all legend layers
	if(document.getElementById("legendButton")) {
		feMap.legendLayers = [];
		feMap.legend.refresh(feMap.legendLayers);
	}	  
	
	//Close any alerts
	clearAlerts();
}

/*------------------------------------*/
// format unix timestamp
/*------------------------------------*/
function formatUnixTimestamp(currentValue){
	if(is_int(currentValue) && currentValue.toString().length == 13){
		// assume it's a unix timestamp and format it as a date
		currentValue = mpfDate(moment(currentValue));
	}
	return currentValue;
}
/*------------------------------------*/
// DISPLAY INFO WINDOW
/*------------------------------------*/
function displayInfoWindow(evt,i){
	var iwtitle = userConfig.layers[i].infoWindow.windowTitle;
	var iwattributes = userConfig.layers[i].attributes;
	clearPopupValues();
	// GENERATE CONTENT
	var iwcontent = '<ul>';
	if(iwattributes && iwattributes.length > 0){
		for(j=0; j < iwattributes.length; j++){
			if(iwattributes[j].url){
				iwcontent += '<li><a target="_blank" href="' + evt.graphic.attributes[iwattributes[j].attributeLabel] + '">' + iwattributes[j].title + '</a></li>';
			}
			else{
				// check if unix timestamp
				var currentValue = formatUnixTimestamp(evt.graphic.attributes[iwattributes[j].attributeLabel]);
				// display
				iwcontent += '<li><strong>' + iwattributes[j].title + ':</strong>&nbsp;' + currentValue + '</li>';
			}
		}
	}
	else{
		var key;
		for(key in evt.graphic.attributes){
			if(evt.graphic.attributes.hasOwnProperty(key)) {
				// check if unix timestamp
				var currentValue = formatUnixTimestamp(evt.graphic.attributes[key]);
				// display 
				iwcontent += '<li><strong>'+key+':</strong>&nbsp;' + currentValue + '</li>';
			}
		}
	}
	iwcontent += '</ul>';
	// SET FEATURES
	feMap.mapPopup.setFeatures([evt.graphic]);
	// ATTACH TITLE
	feMap.mapPopup.setTitle(iwtitle);
	// ATTACH CONTENT
	feMap.mapPopup.setContent(iwcontent);
	// SHOW WINDOW
	feMap.mapPopup.show(evt.screenPoint);
}
/*------------------------------------*/
// CREATE SYMBOL
/*------------------------------------*/
function createSymbol(symbolObject,i,h){
	var newStyle;
	var color;
	var line;
	var fillColor;
	var outlineColor;
	switch(symbolObject.type){
		case 'picture':
			feMap.layerArray[i]['symbol' + h] = new esri.symbol.PictureMarkerSymbol(symbolObject.url, symbolObject.width, symbolObject.height);
			break;
		case "esriPMS":
			feMap.layerArray[i]['symbol' + h] = new esri.symbol.PictureMarkerSymbol(symbolObject);
			break;
		case 'point':
			switch(symbolObject.style){
				case 'circle':
					newStyle = 'STYLE_CIRCLE';
					break;
				case 'cross':
					newStyle = 'STYLE_CROSS';
					break;
				case 'diamond':
					newStyle = 'STYLE_DIAMOND';
					break;
				case 'square':
					newStyle = 'STYLE_SQUARE';
					break;
				case 'X':
					newStyle = 'STYLE_X';
					break;
			}
			// COLOR
			color = new dojo.Color(symbolObject.color);
			// LINE
			line = new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, color, 1);
			// CREATE SYMBOL
			feMap.layerArray[i]['symbol' + h] =  new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol[newStyle], symbolObject.size, line, color);
			break;
		case 'line':
			// COLOR
			color = new dojo.Color(symbolObject.color);
			// STYLE
			switch(symbolObject.style){
				case 'dash':
					newStyle = 'STYLE_DASH';
					break;
				case 'dashdot':
					newStyle = 'STYLE_DASHDOT';
					break;
				case 'dashdotdot':
					newStyle = 'STYLE_DASHDOTDOT';
					break;
				case 'dot':
					newStyle = 'STYLE_DOT';
					break;
				case 'solid':
					newStyle = 'STYLE_SOLID';
					break;
				default:
				newStyle = 'STYLE_SOLID';
			}
			// CREATE SYMBOL
			feMap.layerArray[i]['symbol' + h] = new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol[newStyle], color, symbolObject.size);
			break;
		case 'polygon':
			// COLOR
			fillColor = new dojo.Color(symbolObject.fillColor);
			// COLOR
			outlineColor = new dojo.Color(symbolObject.outlineColor);
			// STYLE
			switch(symbolObject.style){
				case 'backward':
					newStyle = 'STYLE_BACKWARD_DIAGONAL';
					break;
				case 'cross':
					newStyle = 'STYLE_CROSS';
					break;
				case 'diagcross':
					newStyle = 'STYLE_DIAGONAL_CROSS';
					break;
				case 'forward':
					newStyle = 'STYLE_FORWARD_DIAGONAL';
					break;
				case 'horizontal':
					newStyle = 'STYLE_HORIZONTAL';
					break;
				case 'solid':
					newStyle = 'STYLE_SOLID';
					break;
				case 'vertical':
					newStyle = 'STYLE_VERTICAL';
					break;
				default:
					newStyle = 'STYLE_SOLID';
			}
			// LINE
			line = new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, outlineColor, 1);
			// CREATE SYMBOL
			feMap.layerArray[i]['symbol' + h] = new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol[newStyle], line, fillColor);
			break;
		default:
	}	
}


/*------------------------------------*/
// CREATE SYMBOLS
/*------------------------------------*/
function createSymbols(i,type){
	switch(type){
		case 'simpleRenderer':
			createSymbol(userConfig.layers[i].renderer.symbol,i,0);
			break;
		case 'uniqueValueRenderer':
			if(userConfig.layers[i].renderer.categories){
				// FOR INFOS CONFIG LENGTH
				for(h=0; h <userConfig.layers[i].renderer.categories.length; h++){
					// SYMBOL TYPE
					createSymbol(userConfig.layers[i].renderer.categories[h].symbol,i,h);
				}
			}
			break;
		case 'classBreaksRenderer':
			if(userConfig.layers[i].renderer.classBreaks){
				// FOR INFOS CONFIG LENGTH
				for(h=0; h <userConfig.layers[i].renderer.classBreaks.length; h++){
					// SYMBOL TYPE
					createSymbol(userConfig.layers[i].renderer.classBreaks[h].symbol,i,h);
				}
			}
			break;
	}
}

/*------------------------------------*/
//Remove map graphics
/*------------------------------------*/
function removeGraphics() {
	if(feMap.mapFrame.graphics) {feMap.mapFrame.graphics.clear();}
}

/*------------------------------------*/
// CREATE CATEGORIES
/*------------------------------------*/
function createCategories(i){
	if(userConfig.layers[i].uniqueValueRenderer.categories){
		// FOR INFOS CONFIG LENGTH
		for(h=0; h <userConfig.layers[i].uniqueValueRenderer.categories.length; h++){
			feMap.layerArray[i].renderer.addValue({
				value: userConfig.layers[i].uniqueValueRenderer.categories[h].uniqueValue,
				symbol: feMap.layerArray[i]['symbol' + h],
				label: userConfig.layers[i].uniqueValueRenderer.categories[h].label,
				description:  userConfig.layers[i].uniqueValueRenderer.categories[h].description
			});
		}
	}
}
/*------------------------------------*/
// CREATE BREAKS
/*------------------------------------*/
function createBreaks(i){	
	if(userConfig.layers[i].classBreaksRenderer.classBreaks){
		// FOR INFOS CONFIG LENGTH
		for(h=0; h <userConfig.layers[i].classBreaksRenderer.classBreaks.length; h++){
			feMap.layerArray[i].renderer.addBreak({
				minValue: userConfig.layers[i].classBreaksRenderer.classBreaks[h].minValue,
				maxValue: userConfig.layers[i].classBreaksRenderer.classBreaks[h].maxValue,
				symbol: feMap.layerArray[i]['symbol' + h],
				label: userConfig.layers[i].classBreaksRenderer.classBreaks[h].label
			});
		}
	}
}
/*------------------------------------*/
// GET LAYER ORDER INDEX
/*------------------------------------*/
function getItemRow(id) {
	var myPosition = -1;
	if(userConfig.layerOrder){
		for (i=0; i < userConfig.layerOrder.length; i++) {
			if(userConfig.layerOrder[i] === id) {
				myPosition = i;
				break;
			}
		}
	}
	return myPosition;
}

/*------------------------------------*/
// Create Popup
/*------------------------------------*/
function createPopup(){
	feMap.mapPopup = new esri.dijit.Popup({
		fillSymbol: new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_SOLID, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new dojo.Color([255,0,0]), 2), new dojo.Color([255,255,0,0.25])),
		lineSymbol: new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_DASH,
		  new dojo.Color([255,0,0]), 3),
		markerSymbol: new esri.symbol.SimpleMarkerSymbol('circle', 32, null, new dojo.Color([0, 0, 0, 0.25])),
		//marginLeft: 10,
		//marginTop: 10,
		//offsetX:3,
		//offsetY:3,
		zoomFactor:4
	}, dojo.create("div"));
	
}
/*------------------------------------*/
// Create the map object
/*------------------------------------*/
function createMap(){
	var showInfoWindowOnClick = true;
	if (userConfig.application.showInfoWindowOnClick == false) {
		feMap.mapPopup = null;
		showInfoWindowOnClick = false;
	}
	feMap.mapFrame = new esri.Map("map", {
		extent: feMap.startExtent,
		lods: userConfig.application.lods,
		wrapAround180: true,
		slider: false,
		logo: false,
		isScrollWheelZoom: true,
		showInfoWindowOnClick: showInfoWindowOnClick,
		infoWindow: feMap.mapPopup
	});
	
	
	//Initialise the feMap.maxOffset value
	setMaxOffset();
	
}

/******************************************/
//Manage the list of "identifiable" layers. 
/******************************************/
function getIdentifyLayerIndex(layerid){
	var indexNum = feMap.identifyLayers.indexOf(layerid);
	return indexNum;
}
function addToIdentifyLayers(layer){
	var theIndex = getIdentifyLayerIndex(layer);
	if(theIndex === -1){
		feMap.identifyLayers.push(layer);
	}
	
	dojo.disconnect(feMap.identifyListener);
	feMap.identifyListener = dojo.connect(feMap.mapFrame, "onClick", runIdentifies);
	
}
function removeFromIdentifyLayers(layerid){
	var theIndex = getIdentifyLayerIndex(layerid);
	if(theIndex > -1) {
		for(theIndex; theIndex > -1; theIndex = getIdentifyLayerIndex(layerid)) {
			feMap.identifyLayers.splice(theIndex, 1);
		}
	}
	if(feMap.identifyLayers.length==0) {
		dojo.disconnect(feMap.identifyListener);
	}
}


/*------------------------------------*/
// GET BAEMAP INDEX BY UNIQUE ID
/*------------------------------------*/
function getBasemapIndex(id){
	var returnVal = 0;
	var i;
	if(userConfig.basemaps){
		for(i=0; i < userConfig.basemaps.length; ++i){
			if(userConfig.basemaps[i].id === id){
				return i;
			}
		}
	}
	return returnVal;
}

 /*------------------------------------*/
// SET EXTENT
/*------------------------------------*/
function setStartExtentValues(){
	if(!userConfig.application.extent.spatialRef){
		userConfig.application.extent.spatialRef = 102100;
	}
	// SPATIAL REF
	feMap.WMRef = new esri.SpatialReference({
		wkid: userConfig.application.extent.spatialRef
	});
	// If the start extent has been provided in the URL, as the bounding box in Web Mercator
	if(feMap.sXmin && feMap.sYmin && feMap.sXmax && feMap.sYmax) {
		feMap.startExtent = new esri.geometry.Extent({
			xmin: feMap.sXmin,
			ymin: feMap.sYmin,
			xmax: feMap.sXmax,
			ymax: feMap.sYmax,
			spatialReference: feMap.WMRef
		});
	}else {
		// NOT LOADED FROM URL
		feMap.startExtent = new esri.geometry.Extent(
			parseFloat(userConfig.application.extent.xMin),
			parseFloat(userConfig.application.extent.yMin),
			parseFloat(userConfig.application.extent.xMax),
			parseFloat(userConfig.application.extent.yMax),
			feMap.WMRef
		);
		feMap.sXmin = userConfig.application.extent.xMin;
		feMap.sYmin = userConfig.application.extent.yMin;
		feMap.sXmax = userConfig.application.extent.xMax;
		feMap.sYmax = userConfig.application.extent.yMax;
    }
}
/*------------------------------------*/
// RESIZE MAP FUNCTION
/*------------------------------------*/
function resizeMap(){
	//clear any existing resize timer
	clearTimeout(feMap.timer);
	//create new resize timer with delay of 500 milliseconds
	feMap.timer = setTimeout(function(){
		if(map){
			// GET HEIGHT OF MENU BAR
			var barHeight = jQuery('#topMenuBar').height();
			// GET HEIGHT OF MENU BAR
			var chartHeight = jQuery('#graphBar').height();
			// GET HEIGHT OF WINDOW
			var windowHeight = jQuery(window).height();
			// SET MAP HEIGHT
			jQuery('#map').height(windowHeight - barHeight - chartHeight);
			// RESIZE
			feMap.mapFrame.resize();
			feMap.mapFrame.reposition();
			if(userConfig.application.showAboutMenu) {updatePlacesOffset();}
			if(userConfig.application.showShareMenu) {updateShareOffset();}
		}
	}, 500);
}
/*------------------------------------*/
// HIDES INFO WINDOW
/*------------------------------------*/
function hidePopup(){
	feMap.mapPopup.hide();
}
/*------------------------------------*/
// HIDE STUFF
/*------------------------------------*/
function clearPopupValues(){
	feMap.mapPopup.setContent('');
    feMap.mapPopup.setTitle('');
	feMap.mapPopup.clearFeatures();
}
/*------------------------------------*/
// clear the locate graphic
/*------------------------------------*/
function resetLocateLayer() {
    if (feMap.locateResultLayer){
        feMap.locateResultLayer.clear();
    }
    feMap.locateString = "";
    setSharing();
}
/*------------------------------------*/
// CHECK GRAPHIC
/*------------------------------------*/
function checkGraphic(evt){
    if (evt.graphic) {
        return;
    }
    else {
        hidePopup();
    }
}
/*------------------------------------*/
// Check to see if scalebar should be shown
/*------------------------------------*/
function checkScaleBar(){
    if (feMap.xScalebar) {
        if (feMap.mapFrame.getLevel() < 5) {
            feMap.xScalebar.hide();
        }
        else {
            feMap.xScalebar.show();
        }
    }
}
/*------------------------------------*/
// search box functions
/*------------------------------------*/ 
function autoComplete(query) {
	var address = {
		SingleLine: query
	};
    feMap.aoGeoCoderAutocomplete.addressToLocations(address,["*"]);
	clearTimeout(feMap.acHideTimer);
	feMap.acHideTimer = setTimeout(hideAC,6000);
}
/*------------------------------------*/
// LOCATE 
/*------------------------------------*/
function locate() {
    var query = jQuery('#address').val();
    if(query){
		var address = {
			SingleLine: query
		};
		feMap.aoGeocoder.addressToLocations(address,["*"]);
		feMap.locateString = query;
		setSharing();
	}
	else{
		raiseAlert("Search","Please enter a search location.");
	}
}

function gazetteerSearch(query) {
	// Just zoom to the first result if the user hits Enter
	feMap.gazQuery.where = "upper(" + userConfig.application.gazetteer.nameField + ") like '" + query.toUpperCase() + "%'";
	feMap.gazQueryTask.execute(feMap.gazQuery, function(gazetteerResults) {
		if(gazetteerResults.features.length > 0) {
			zoomToGazetteerResult(gazetteerResults.features[0]);
		} else {
			raiseAlert("Gazetteer error", "Unable to find a matching feature");
		}
	});

}

function gazetteerSearchAutoComplete(query) {
	feMap.gazQuery.where = "upper(" + userConfig.application.gazetteer.nameField + ") like '" + query.toUpperCase() + "%'";
	feMap.gazQueryTask.execute(feMap.gazQuery, showGazetteerAutoCompleteResults);
}

function showGazetteerAutoCompleteResults(gazResults) {
	//Display the results in the AutoComplete popup
	var autoCompleteObj = jQuery('#autoComplete');
	var addressPosition = jQuery('#address').parent('.iconInput').offset();
	autoCompleteObj.css({'left': addressPosition.left+'px', 'top': addressPosition.top+28+'px'});
	var aResults = '';
	
	if(gazResults.features.length > 0){
		feMap.ACObj = gazResults;
		aResults += '<ul class="zebraStripes">';
		var i;
		var maxResults = 25;
		if(gazResults.features.length < maxResults) {maxResults = gazResults.features.length;}
		for(i=0; i < maxResults; ++i){
		    var layerClass = '';
		    if(i % 2 === 0){
		        layerClass = '';
		    }
		    else{
		        layerClass = 'stripe';
		    }
		  aResults += '<li tabindex="'+ (i + 2) +'" class="'+ layerClass +'">' + gazResults.features[i].attributes[userConfig.application.gazetteer.nameField]  + '</li>';
		}
		aResults += '</ul>';
		if(gazResults.features.length > 0){
			autoCompleteObj.html(aResults).show();
		}
	} else{
		hideAC();
	}
}

function zoomToGazetteerResult(feature) {

	//Set the Address Search text
	jQuery('#address').val(feature.attributes[userConfig.application.gazetteer.nameField]);
	
	if(feMap.locateResultLayer) {
		feMap.locateResultLayer.clear();
		clearPopupValues();
		hidePopup();
	}
	else{
		feMap.locateResultLayer = new esri.layers.GraphicsLayer();
		dojo.connect(feMap.locateResultLayer, "onClick",function(evt){
			var content = "<strong>" + evt.graphic.attributes["Name"] +"</strong>";
			feMap.mapPopup.setContent(content);
			var title = "Location";
			feMap.mapPopup.setTitle(title);
			var height = 180
			var width = 100
			if(userConfig.application.locatorPopup) {
				height = userConfig.application.locatorPopup.height;
				width = userConfig.application.locatorPopup.width;
			}
			feMap.mapPopup.resize(height,width);
			feMap.mapPopup.show(evt.graphic.geometry);
		});
		feMap.mapFrame.addLayer(feMap.locateResultLayer);
	}
	
	// SET EXTENT VARIABLES
	var lat = feature.attributes[userConfig.application.gazetteer.latField];
	var lon = feature.attributes[userConfig.application.gazetteer.lonField];
	var wkid = userConfig.application.gazetteer.wkid;
	var pt = new esri.geometry.Point(lon, lat, new esri.SpatialReference({ wkid: wkid }));
	if (wkid === 4326 || wkid === 4283) {
		pt = esri.geometry.geographicToWebMercator(pt)
	}
	
	// CREATE POINT MARKER
	var pointSymbol = new esri.symbol.PictureMarkerSymbol(userConfig.application.pointSymbol, 21, 29).setOffset(0,12);
	var locationGraphic = new esri.Graphic(pt,pointSymbol);
	locationGraphic.setAttributes({"Name":feature.attributes[userConfig.application.gazetteer.nameField] });
	feMap.locateResultLayer.add(locationGraphic);
	
	// Zoom to the new extent
	feMap.buffer = userConfig.application.gazetteer.buffer || 5000;
	var newExtent = new esri.geometry.Extent({
		xmin: pt.x - feMap.buffer,
		ymin: pt.y - feMap.buffer,
		xmax: pt.x + feMap.buffer,
		ymax: pt.y + feMap.buffer,
		spatialReference: feMap.WMRef
	});
	feMap.mapFrame.setExtent(newExtent);
}

/*------------------------------------*/
// SHOW AUTOCOMPLETE
/*------------------------------------*/
function showAutoComplete(geocodeResults){
    var aResults = '';
    var addressPosition = jQuery('#address').parent('.iconInput').offset();
    var partialMatch = jQuery('#address').val();
    var regex = new RegExp('('+ partialMatch +')','gi');
	var autoCompleteObj = jQuery('#autoComplete');
    autoCompleteObj.css({'left': addressPosition.left+'px', 'top': addressPosition.top+28+'px'});
    if(geocodeResults !== null){
        feMap.ACObj = geocodeResults;
        aResults += '<ul class="zebraStripes">';
		var i;
        for(i=0; i < geocodeResults.length; ++i){
            var layerClass = '';
            if(i % 2 === 0){
                layerClass = '';
            }
            else{
                layerClass = 'stripe';
            }
          aResults += '<li tabindex="'+ (i + 2) +'" class="'+ layerClass +'">' + geocodeResults[i].address.replace(regex,'<span>' + partialMatch + '</span>')  + '</li>';
        }
        aResults += '</ul>';
        if(geocodeResults.length > 0){
			autoCompleteObj.html(aResults).show();
		}
		else{
			hideAC();
		}
    }
}


/*------------------------------------*/
// SHOW RESULTS
/*------------------------------------*/
function showGeocodeResults(geocodeResults, resultNumber){
	// IF RESULT
	if(geocodeResults.length > 0){
		// NUM RESULT VARIABLE
		var numResult = 0;
		// IF RESULT NUMBER
		if(resultNumber){
			numResult = resultNumber;
		}
		// IF LOCATE RESULTS
		if(feMap.locateResultLayer) {
			feMap.locateResultLayer.clear();
			clearPopupValues();
			hidePopup();
		}
		else{
			feMap.locateResultLayer = new esri.layers.GraphicsLayer();
			dojo.connect(feMap.locateResultLayer, "onClick",function(evt){
			var content = "<strong>" + evt.graphic.attributes.address +"</strong>";
			feMap.mapPopup.setContent(content);
			var title = "Location";
			feMap.mapPopup.setTitle(title);
			feMap.mapPopup.show(evt.graphic.geometry);
			});
			feMap.mapFrame.addLayer(feMap.locateResultLayer);
		}
		// CREATE POINT MARKER
		var pointMeters = esri.geometry.geographicToWebMercator(geocodeResults[numResult].location);
		var pointSymbol = new esri.symbol.PictureMarkerSymbol(userConfig.application.pointSymbol, 21, 29).setOffset(0,12);
		var locationGraphic = new esri.Graphic(pointMeters,pointSymbol);
		locationGraphic.setAttributes({"address":geocodeResults[numResult].address });
		feMap.locateResultLayer.add(locationGraphic);
		// SET EXTENT VARIABLES
		var xminNew = parseFloat(geocodeResults[numResult].attributes.West_Lon);
		var yminNew = parseFloat(geocodeResults[numResult].attributes.South_Lat);
		var xmaxNew = parseFloat(geocodeResults[numResult].attributes.East_Lon);
		var ymaxNew =  parseFloat(geocodeResults[numResult].attributes.North_Lat);
		// CREATE NEW EXTENT
		var newExtent = new esri.geometry.Extent({
			xmin: xminNew,
			ymin: yminNew,
			xmax: xmaxNew,
			ymax: ymaxNew,
			spatialReference: feMap.WMRef
		});
		// SET EXTENT CONVERTED TO WEB MERCATOR
		feMap.mapFrame.setExtent(esri.geometry.geographicToWebMercator(newExtent));
	}
	else{
		raiseAlert("Search error","Location could not be found.");
		resetLocateLayer();
		clearAddress(jQuery('#address'));
	}
	hideAC();
}

function runIdentifies(evt) {

	//don't run this function if the user has clicked on a graphic
	if(evt.graphic) {return null;}

	//Hold a reference to the point clicked, so the Identify window can be anchored here
	feMap.identifyMapPoint = evt.mapPoint;

	feMap.mapFrame.infoWindow.hide();
	
	//Set a waiting cursor to let the user know there's a process running. Revert to the 
	//standard cursor when the Identify tasks returns a result
	feMap.mapFrame.setCursor("wait");
	
	//Report the number of selected features in the popup
	dojo.connect(feMap.mapFrame.infoWindow,"onSelectionChange",function(){
		var idx = feMap.mapFrame.infoWindow.selectedIndex + 1;
		feMap.mapFrame.infoWindow.setTitle("(" + idx + " of " + feMap.mapFrame.infoWindow.count + ")");
	});
	
	//We are already maintaining a list of "identifiable" layers, controlled by the TOC
	var layers = feMap.identifyLayers;
	    
    //map each identify layer to a new identify task, using the layer url
    feMap.tasks = dojo.map(layers, function(layer) {
        return new esri.tasks.IdentifyTask(layer.url);
    }); 
    
    //map each identify task to a new dojo.Deferred
    feMap.defTasks = dojo.map(feMap.tasks, function (task) {
        return new dojo.Deferred();
    }); 
    
    //Use all of these Deferreds in a DeferredList
    feMap.dlTasks = new dojo.DeferredList(feMap.defTasks); 
    feMap.dlTasks.then(showIDResults); //chain showIDResults onto the DeferredList
      
    //Use 'for' instead of 'for...in' to sync tasks with feMap.defTasks
    for (i=0;i<feMap.tasks.length;i++) { 
        try {
        
        	//Configure the identify parameters
        	var idParams = new esri.tasks.IdentifyParameters();
        	idParams.tolerance = userConfig.application.identifyTolerance;
        	idParams.returnGeometry = true;
        	idParams.layerOption = esri.tasks.IdentifyParameters.LAYER_OPTION_VISIBLE;
        	idParams.width = feMap.mapFrame.width;
        	idParams.height = feMap.mapFrame.height;
        	idParams.maxAllowableOffset = feMap.maxOffset;
        	idParams.geometry = evt.mapPoint;
        	idParams.mapExtent = feMap.mapFrame.extent;
        	idParams.allowIdentify = feMap.identifyLayers[i].layerInfo.allowIdentify;
        	        	
        	//Build an array of the layers to be identified
        	var idLayers = [];
        	var numIDLayers = idParams.allowIdentify.length;
        	for (var x = 0; x < numIDLayers; x++) {
	    		idLayers.push(idParams.allowIdentify[x].layerId);        	
        	}
        	idParams.url = feMap.identifyLayers[i].url;
        	idParams.layerIds = idLayers;
        	        	
			//Execute the task
            feMap.tasks[i].execute(idParams, feMap.defTasks[i].callback, feMap.defTasks[i].errback); //Execute each task
        } catch (e) {
            console.log("Error caught");
            console.log(e);
            feMap.defTasks[i].errback(e); //If you get an error for any task, execute the errback
        }
    }
}

function showIDResults(r) {

	//console.log(r.length, feMap.identifyLayers.length);
  
    var results = [];
    r = dojo.filter(r, function (result) {
        return r[0];
    }); //filter out any failed tasks
    for (i=0;i<r.length;i++) {
        results = results.concat(r[i][1]);
    }
    
    //Find the relevant allowIdentify for each result. This is a slight hack, given that the identifyResult object
    //can't tell us, definitively, which layer it's from. The best workaround is to find out the layerName, and
    //compare it to the .mapServiceName property on the layer object. A limitation is that layer names must be unique.
    //TODO: expand this explanation further
    //Build up an array of features to be returned to the infoWindow
    var features = [];
    
    //Iterate through each result to see whether there is a corresponding allowIdentify specification for this layer.
    var numResults = results.length;
    for (var x = 0; x < numResults; x++) {
    	
    	//Find the layer name. This is the name specified in ArcMap, and carried through to the REST API.
    	var resultLayerName = results[x].layerName;
    	var resultLayerId = results[x].layerId;
    	
    	//Find the corresponding allowIdentify object, which will be found in the identifyLayers array
    	var numIDLayers = feMap.identifyLayers.length;
    	for(var y=0;y<numIDLayers;y++){
    		var lyr = feMap.identifyLayers[y];
    		//var allowIdentify = lyr.allowIdentify;
    		var wantedLayerId = lyr.primaryLayerId;
			var mapServiceName = lyr.primaryLayerMapServiceName;
			if(resultLayerId == wantedLayerId && resultLayerName == mapServiceName) {
				//We're interested in this layer, so build up an infoTemplate from its attributes
				var feature = results[x].feature;
				feature.attributes.layerName = results[x].layerName;
				    				
				//Build up a table from the aliases and attributes. Format numerical values.
				contents = "<table style='width:100%;'>";
				var attributes = lyr.attributes;
				var numAttr = attributes.length;
				for (var a = 0; a < numAttr; a++) {
					if(!attributes[a].hide) {
    					var value = feature.attributes[attributes[a].name];
    					if(dojo.number.format(value)) {
    						value = dojo.number.format(value);
    					}
    					var label = attributes[a].alias || attributes[a].name;
						contents += "<tr><td><strong>" + label + ":</strong></td><td>" + value + "</td></tr>";
					}
				}
				contents += "</table>"; 
				var infoTemplate = new esri.InfoTemplate(feature.attributes.layerName, contents);
				feature.setInfoTemplate(infoTemplate);	
				features.push(feature);    			   	
			}
    	} 
    }
    
    //Display the infoWindow if there are any features
    if(features.length === 0) {
        feMap.mapFrame.infoWindow.clearFeatures();
    } else {
        feMap.mapFrame.infoWindow.setFeatures(features);
    }
    feMap.mapFrame.infoWindow.show(feMap.identifyMapPoint);
        
    //Revert the mouse cursor to normal
    feMap.mapFrame.setCursor("default");
    
    return features; 
          
   }


/*----------------------------------*/
//SL. BUILD HIGHCHART
/*----------------------------------*/

function buildChart(graphic) {
    var highChart = this.highChart;
    var fields = highChart.chartData.fields;
    feMap.mapFrame.infoWindow.hide();

    try {
        dojo.disconnect(prevInfoWindowOnShowHandler);
    } catch (e) {}
       
    prevInfoWindowOnShowHandler = dojo.connect(feMap.mapFrame.infoWindow, "onShow", function () {
        //build the series - we need to do this on-the-fly since the values aren't
        //known until the user clicks on a feature
        var attr = graphic.attributes;
        var series = new Array();
        
        var numSeries = highChart.chartData.data.series.length;
        for (var i = 0; i < numSeries; i++) {
            var fields = highChart.chartData.data.series[i].fields;
            var multiplier = highChart.chartData.data.series[i].multiplier || 1;
            var other = highChart.chartData.data.series[i].other || null;
            var field = fields[0];
            var data = new Array();
            data[0] = attr[field] * multiplier;
            var numFields = fields.length;
            for (var x = 1; x < numFields; x++) {
                var field = fields[x];
                data[x] = attr[field] * multiplier;
            }

            //If this series has an "other" category
            if (other != null) {
                //Summarise the "other" fields into a single value
                var otherTotal = 0;
                var len = other.length;
                for (var o = 0; o < len; o++) {
                    otherTotal += attr[other[o]];
                }
                //Add the keyword "other" to the labels
                highChart.chartData.xAxis.categories.push("other");
                //Add the "other" total to the data
                data.push(otherTotal);
            }
            series[i] = new Object();
            series[i].name = highChart.chartData.data.series[i].name
            series[i].data = data;
        }
                        
        //Add the chart's title, truncated if necessary
        if (highChart.titleField) {
        	var title = highChart.labels.title + " - " + graphic.attributes[highChart.titleField];
        } else {
	        var title = highChart.labels.title;
	    }
        if (title.length > 80) {
            title = title.substring(title, 80) + "...";   
        }            
        
        //Set the subtitle if specified
        var subtitle = ""
        if(highChart.labels.subtitle) {
        	subtitle = highChart.labels.subtitle;
        }
        
        //If the user has specified a link, evaluate it
        if(highChart.labels.link) {
        	var link = highChart.labels.link;
        	var prefix = link.prefix;
        	var variable = link.variable;
        	var suffix = link.suffix;
        	var label = link.label;
        	subtitle = '<a target="_blank" href="' + prefix + graphic.attributes[variable] + suffix + '">' + label + '</a>'
        }   

        var chart = new Highcharts.Chart({
            chart: {
                renderTo: 'container',
                defaultSeriesType: highChart.setup.chartType,
                marginRight: highChart.setup.marginRight || 0,
                marginBottom: highChart.setup.marginBottom || 0
            },
            legend: {
                //show the legend if there is more than one series
                enabled: highChart.chartData.data.series.length > 1
            },
            title: {
                text: title
            },
            subtitle: {
                text: subtitle
            },
            xAxis: highChart.chartData.xAxis,
            yAxis: highChart.chartData.yAxis,
            tooltip: highChart.chartData.tooltip,
            plotOptions: highChart.chartData.plotOptions || {
                series: {
                    stacking: 'normal'
                }
            },
            series: series
        });
    });
    //Resize the map's infoWindow to suit this layer
    var infoWindowWidth = 610;
    if (highChart.setup.width) {
    	infoWindowWidth = highChart.setup.width;							
    }
    var infoWindowHeight = 350;
    if (highChart.setup.height) {
    	infoWindowHeight = highChart.setup.height;							
    }
    feMap.mapFrame.infoWindow.resize(infoWindowWidth,infoWindowHeight);
    var width = infoWindowWidth - 15;
    var height = infoWindowHeight - 40;
    return "<div id='container' style='width: " + width + "px; height: " + height + "px;'></div>";
}

function setMaxOffset() {
	//Simplifies geometries based on the current map size
	feMap.maxOffset = Math.floor(feMap.mapFrame.extent.getWidth() / feMap.mapFrame.width) * userConfig.application.offsetTolerance;
}

function zoomToStartExtent() {
	feMap.mapFrame.setExtent(feMap.startExtent);
}

function checkTOCVisibility() {
	var numLayers = feMap.mapLayers.length;
	for (var i=0; i<numLayers; i++) {
		var layer = feMap.mapLayers[i];
		var identifyIndex = getIdentifyLayerIndex(layer);
		var minScale = layer.minScale;
		var maxScale = layer.maxScale;
	
		if(minScale != 0 && currentMapScale > minScale || maxScale != 0 && currentMapScale < maxScale) {
			//If the layer is outside its scale range, force its visibility off. It will be shown checked on but grey in the TOC
			jQuery('#layer-' + layer.id).addClass("grey");
			jQuery('#layer-' + layer.id).removeClass("cLoading");
			layer.setVisibility(false);

			//If this is a dynamic layer, remove it from the list of "identifiable" layers (if it's currently listed)
			if(layer.allowIdentify && identifyIndex > -1){
				removeFromIdentifyLayers(layer);
			}		
		}else{
			//If the layer is within its scale range, and checked on, switch it on
			if(jQuery('#layer-' + layer.id).hasClass("checked")) {
				layer.setVisibility(true);
			}
			jQuery('#layer-' + layer.id).removeClass("grey");
			
			//If this is a visible, identifiable layer, add it to the list of "identifiable" layers (if it isn't already listed)
			if(layer.visible && layer.layerInfo.allowIdentify && identifyIndex <0){
				addToIdentifyLayers(layer);
			}	
		}
	}
}

function createLegend() {
	
	feMap.legend = new esri.dijit.Legend({
		map:map,
		layerInfos:feMap.legendLayers
	},"legendDiv");
	feMap.legend.startup();
		
	//TODO: how to display a legend for cluster layers? GraphicsLayers are not supported in the legend
	//so we might need to create a feature layer?
}

function updateLegendLayerInfos() {

	//Iterate through all map layers to find only those which support a legend
	feMap.legendLayers = [];
	var layers = feMap.mapFrame.graphicsLayerIds.concat(feMap.mapFrame.layerIds);
	jQuery.each(layers,function(index,layerId){
		var layer = feMap.mapFrame.getLayer(layerId);
		if(layer) {
			if(layer.showLegend) {
				var title = layer.title;
				feMap.legendLayers.push({layer:layer, title:title, id:layerId});
			}
		}	
	});
	feMap.legend.refresh(feMap.legendLayers);
}

/******************************************/
//Manage the list of cluster layers. 
/******************************************/
function getClusterLayerIndex(layerid){
	var indexNum = feMap.clusterLayers.indexOf(layerid);
	return indexNum;
}
function addToClusterLayers(layerid){
	var theIndex = getClusterLayerIndex(layerid);
	if(theIndex === -1){
		feMap.clusterLayers.push(layerid);
	}
}
function removeFromClusterLayers(layerid){
	var theIndex = getClusterLayerIndex(layerid);
	if(theIndex > -1) {
		for(theIndex; theIndex > -1; theIndex = getClusterLayerIndex(layerid)) {
			feMap.clusterLayers.splice(theIndex, 1);
		}
	}
}

function errCluster(err) {
	if(userConfig.application.development) {
		console.log("Problem running a cluster query");
	}
}

function switchOn(layerId) {
	//switch on the layer, and toggle its checkbox entry on
	var layer = feMap.mapFrame.getLayer(layerId);	
	addToActiveLayers(layerId);
	jQuery('#layer-'+layerId).addClass('checked');
	if(layer) {
		layer.show();
		if(layer.allowIdentify){
			addToIdentifyLayers(layer);
		}
		if(layer.tiles){
			addToTileLayers(layer.id);
		}
	}
}

function switchOff(layerId) {

	//Switch the layer off. Toggle it off in the TOC, from the list of active layers, and the list of identifiable layers
	var layer = feMap.mapFrame.getLayer(layerId);
	jQuery('#layer-'+layerId).removeClass('checked');
	removeFromActiveLayers(layerId);
	if(layer) {
		//jQuery('#layersMenu .layer[data-layer=' + layerId + ']').removeClass('checked');	
		layer.hide();
		layer.setVisibility(false);
		removeGraphics();
		if(layer.allowIdentify){
			removeFromIdentifyLayers(layer);
		}
		if(layer.tiles){
			removeFromTileLayers(layer.id);
		}
	}
}

function setupDropZone() {
    //set the map canvas as the "drop zone" for new files.
    var node = dojo.byId("map");
    dojo.connect(node, "dragenter", function(evt) {evt.preventDefault();});
    dojo.connect(node, "dragover", function(evt) {evt.preventDefault();});
    dojo.connect(node, "drop", handleDrop);
}

function orientationChanged() {
	if(feMap.mapFrame) {
		feMap.mapFrame.reposition();
		feMap.mapFrame.resize();
	}
}

/******************************************/
// Functions to handle layers which support tiles (which are a form of docked infoWindows). 
/******************************************/
function getTileLayerIndex(layerid){
	var indexNum = feMap.tileLayers.indexOf(layerid);
	return indexNum;
}
function addToTileLayers(layerid){

	var theIndex = getTileLayerIndex(layerid);
	if(theIndex === -1){
		feMap.tileLayers.push(layerid);
	}
	dojo.disconnect(feMap.tileListener);
	if(feMap.tileLayers.length > 0) {
		feMap.tileListener = dojo.connect(feMap.mapFrame, "onExtentChange", updateTiles)
		updateTiles();
	}	
}

function removeFromTileLayers(layerid){
	var theIndex = getTileLayerIndex(layerid);
	if(theIndex > -1) {
		for(theIndex; theIndex > -1; theIndex = getTileLayerIndex(layerid)) {
			feMap.tileLayers.splice(theIndex, 1);
		}
	}
	
	//Also hide this layer's tiles
	var tileLayer = feMap.mapFrame.getLayer(layerid);
	if (tileLayer) {			
		var articles = tileLayer.getLayers();
		var numArticles = articles.length;
		for (var a = 0; a < numArticles; a++) {	
			var localArticle = articles;	  				
			jQuery.each(articles[a].graphics,function(index,value){
				var md5Id = md5(localArticle[a].id+value.attributes.name);
				//find the corresponding tile
				var tile = jQuery.grep(jQuery("#doc-container li"),function(n,i){return n.id == "item"+md5Id})[0];
				jQuery(tile).stop().fadeOut(1000);		
			});
		}
	}	
	
	//If there are no more tile layers, disconnect the listener
	if(feMap.tileLayers.length == 0) {
		dojo.disconnect(feMap.tileListener);
		updateTiles();
	}
}

function updateTiles() {
	//Update the visibility of tiles, to only show those within the current map extent
	jQuery("#doc-container li").css("display", "none");	
	var numTileLayers = feMap.tileLayers.length;
	for(var i = 0; i < numTileLayers; i++) {
		var tileLayer = feMap.mapFrame.getLayer(feMap.tileLayers[i]);
		if (tileLayer) {			
			var articles = tileLayer.getLayers();
			var numArticles = articles.length;
			for (var a = 0; a < numArticles; a++) {	
	    		var graphicsSize = articles[a].graphics.length;				  				
				var localArticle = articles;
	    		var lotsOfGraphics = false;
	    		if (graphicsSize > 500) lotsOfGraphics = true;
	    		if (lotsOfGraphics) {
		    		jQuery("#doc-container").html("");
		    		getTiles();	
	    		} else {
				
					jQuery.each(articles[a].graphics,function(index,value){
						//find the corresponding tile
						var md5Id = md5(localArticle[a].id+value.attributes.name);
	
						tile = jQuery.grep(jQuery("#doc-container li"),function(n,i){return n.id == "item"+md5Id})[0];
						if(tile) {
							if (feMap.mapFrame.extent.contains(value.geometry)) {
								if (jQuery(tile).css("display") == "none") {
									jQuery(tile).stop().fadeIn();
								}
							}
						}		
					});
				}
			}
	    }
	}
}

function getTiles() {

	//Retrieve tiles associated with the current visible tile layers
	var numTileLayers = feMap.tileLayers.length;
	for(var i = 0; i < numTileLayers; i++) {
		var tileLayer = feMap.mapFrame.getLayer(feMap.tileLayers[i]);
		if (tileLayer) {	
			if (!tileLayer.tileBuilt) {

		    	var articles = tileLayer.getLayers();
		    	var numArticles = articles.length;
		    	for (var a = 0; a < numArticles; a++) {
		    		var localArticle = articles;
		    		var graphicsSize = articles[a].graphics.length;
		    		var lotsOfGraphics = false;
		    		if (graphicsSize > 500) {
		    			lotsOfGraphics = true;
		    			tileLayer.tileBuilt = false;
		    		} else {
			    		tileLayer.tileBuilt = true;
		    		}

					jQuery.each(articles[a].graphics,function(index,value){

						var md5Id = md5(localArticle[a].id+value.attributes.name);
						if(document.getElementById("item"+md5Id)) {
							var existingLayer = jQuery("#item"+md5Id);
							existingLayer.fadeIn();
							existingLayer.attr("data-geometry", existingLayer.attr("data-geometry") + "," + index);
						} else {
							if (feMap.mapFrame.extent.contains(value.geometry)) {
								display = "visible"
							} else {
								display = "none";
							}
							var displayIt = false;
							if (!lotsOfGraphics) {
								displayIt = true;
							} else {
								if (feMap.mapFrame.extent.contains(value.geometry)) {
									displayIt = true;
								} else {
									displayIt = false;
								}
							}
							if (displayIt) {
								var description = value.attributes.description.split(".")[0];
								var imgHTML = "";
								var img = this.getLayer().renderer.getSymbol(this);
								if (img) {
									imgHTML = "<img src='" + img.imageData + "' />";
								}
								var orgHeight = img.height;
								var orgWidth = img.width;
								if (lotsOfGraphics) this.hide();
								tile = jQuery('<li data-geometry=' + index + ' id="item'+md5Id+'" style="display:' + display+ '"><h4>' + value.attributes.name + "</h4><span class='summary'>" + imgHTML + value.attributes.description +  "...</span></li>");
								jQuery(tile).hover(
									function() {
										//img.setHeight(100);
										//img.setWidth(100);
										var localIndexes = jQuery(this).attr("data-geometry").split(",");
										var numIndexes = localIndexes.length;
										for (var yy = 0; yy < numIndexes; yy++) {
											var thisLayer = value.getLayer();
											if (lotsOfGraphics) {
												thisLayer.graphics[localIndexes[yy]].show();
											} else {
												thisLayer.graphics[localIndexes[yy]].setSymbol(img);
											}
										}
									},
									function() {
										img.setHeight(orgHeight);
										img.setWidth(orgWidth);
										var localIndexes = jQuery(this).attr("data-geometry").split(",");
										var numIndexes = localIndexes.length;
										for (var yy = 0; yy < numIndexes; yy++) {
											var thisLayer = value.getLayer();
											if (lotsOfGraphics) {
												thisLayer.graphics[localIndexes[yy]].hide();
											} else {
												thisLayer.graphics[localIndexes[yy]].setSymbol(img);
											}
										}
	
										
									}
								);
								jQuery(tile).click(function() {
									var fullPosition = jQuery(this).find(".summary").attr("class").indexOf("full-story");
									if (fullPosition >= 0) {
										jQuery(this).find(".summary").removeClass("full-story");									
									} else {
										jQuery(this).find(".summary").addClass("full-story");									
									}
	
								});
								jQuery("#doc-container").append(tile);
							}
						}
					});
			    }
			 }
		}
	}
}
